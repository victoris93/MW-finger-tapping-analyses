---
title: 'TMS: Model Selection'
author: "Victoria Shevchenko"
date: "4/3/2022"
editor_options:
  chunk_output_type: console
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, 
                      results="asis",
                      out.extra = 'style="display:block; margin: auto"',
                      fig.align = "center", dpi=200)

library(brms)
library(bayesplot)
library(tidybayes)
library(tidyr)
library(purrr)
library(dplyr)
library(ggplot2)
library(tidyverse)
theme_set(theme_bw())
```

```{r, include = F, echo = F}
cache.get.fname <- function(varname, base){
  if(is.null(base))
    bname<-tools::file_path_sans_ext(basename(this.file.name()))
  else
    bname<-tools::file_path_sans_ext(basename(base))
  fname<-file.path('cache', 'vars', sprintf("%s_%s.RData",bname,varname))
  fname  
}
if.cached.load <- function(vname, expr,base=bname){
  if(!is.cached.var(vname, base=bname)){
    val=eval.parent(expr)
    assign(vname, val, envir=.GlobalEnv)
    cache.var(vname, bname)
  } else {
    val <- load.cache.var(vname,bname)
  }
  return(val)
}
is.cached.var <- function(varname, base=NULL){
  fname<-cache.get.fname(varname, base)
  file.exists(fname)
}
cache.var <- function(varname, base=NULL){
  fname<-cache.get.fname(varname, base)
  print(fname)
  printf("CACHE> saving %s to %s\n", varname, fname)
  dir.create(dirname(fname), showWarnings = FALSE)
  save(list = varname, envir = .GlobalEnv, file = fname)
}
uncache.var <- function(varname, base=NULL){
  fname<-cache.get.fname(varname, base)
  cat(sprintf("Deleting %s\n", fname))
  unlink(fname)
}

uncache.all <- function(base=NULL){
  if(is.null(base))
    bname<-tools::file_path_sans_ext(basename(this.file.name()))
  else
    bname<-tools::file_path_sans_ext(basename(base))
  fnames=list.files(file.path('cache', 'vars'), pattern = sprintf("%s*", bname), full.names=T)
  for(fname in fnames){
    cat(sprintf("Deleting %s\n", fname))
    unlink(fname)
  }
}

load.cache.var <- function(varname, base=NULL){
  fname<-cache.get.fname(varname, base)
  printf("CACHE> loading %s from %s\n", varname, fname)
  load(fname)
  return(eval(parse(text=varname)))
}

printf <- function(s, ...){
  cat(sprintf(s, ...))
}

loo_wrapper <- function(...) {
  dots <- list(...)
  if (!"x" %in% names(dots)) {
    names(dots)[1] <- "x"
  }
  do.call(brms::loo, dots)
}
model_weights_wrapper <- function(...) {
  dots <- list(...)
  if (!"x" %in% names(dots)) {
    names(dots)[1] <- "x"
  }
  do.call(brms::model_weights, dots)
}


fit_and_plot <- function(mod.name,frm,load.only=T,plot.only.new=F,init="random", dataset){
  #mod.name = formula.name.fname(frm)
  is.new=TRUE
  if(!is.cached.var(mod.name, base=bname)){
    mod <- brm(frm, data = dataset, family =cumulative("probit"), init=init, iter = 5000, control = list(adapt_delta = 0.99, max_treedepth = 12)) %>% #control = list(adapt_delta = 0.99, max_treedepth = 12)
      add_criterion(c("loo"))
    assign(mod.name, mod, envir=.GlobalEnv)
    cache.var(mod.name, bname)
  } else {
    mod <- load.cache.var(mod.name,bname)
    is.new=FALSE
  }
  if(!load.only & ((is.new & plot.only.new) | (!plot.only.new))  ){
    pdf(plot.filename(sprintf("diag_%s.pdf", mod.name),bname), width=5, height=5)
    mcmc_rhat(brms::rhat(mod)) %>% print
    mcmc_neff(brms::neff_ratio(mod)) %>% print
    #dev.off()
    
    
    mcmc_intervals_data(as.matrix(mod), prob_outer = 0.95) %>%
      filter(parameter!="lp__", !str_detect(parameter, "subj")) %>%
      ggplot(aes(y=m, ymin=ll,ymax=hh,x=parameter))+
      geom_pointrange(position=position_dodge(width=0.2))+
      coord_flip()
    ggsave(plot.filename(sprintf("coef_%s.pdf",mod.name),bname), width=9,height=6)
    
    fit=mod
    nrep=100
    pred=predict(fit)
    
    dataset %>%
      cbind(
        replicate(n=nrep, apply(pred, 1, function(x){sample(1:4,1, prob=x)})) 
      )   %>%
      gather(sim.n,sim.response, 13:(13+nrep-1)) %>%
      group_by(randomization, condition, sim.n) %>%
      do({
        tibble(response=1:4,n=tabulate(.$sim.response, nbins=4))
      }) -> dataset.pred
    
    d.tab=dataset %>% group_by(randomization, condition) %>%
      do({
        v=as.numeric(data.frame(.)[,"probe.response"])
        tibble(response=1:4,n=tabulate(v, nbins=4))
      })
    
    dataset.pred %>% ungroup %>% 
      ggplot(aes(x=factor(response),y=n,color=condition))+
      geom_bar(data=d.tab, mapping=aes(fill=condition), stat="identity",position = position_dodge(width=1), alpha=0.2)+
      #geom_violin(aes(group=interaction(stim_setting,response),color=NULL),fill="grey",color=0, alpha=1, position=position_dodge(width=1))+
      stat_summary(fun.data = mean_qi,  position=position_dodge(width=1), geom="pointrange") +
      #facet_wrap(~question,ncol=1) +
      facet_grid(condition~.) +
      labs(x="Response",y="Number of subjects",
           title=sprintf("%s: Posterior predictive", fit$formula$resp), 
           subtitle=toString(capture.output(fit$formula)))
    
    #ggsave(plot.filename(sprintf("ppred_%s.pdf",mod.name),bname), width=9,height=6)
  }
  return(mod)
}


```


```{r, include = F, echo = F}
setwd(getwd())
load("tms_data_preprocessed.Rdata")

bname = "tms_analyses"

models_task <- list(
  formula(probe.response ~ zbv * zlog.apen + (1|subj/condition)), # which effect should be nested within subjects? 
  formula(probe.response ~ zbv * zlog.apen + probeix + (1|subj/condition)),
  formula(probe.response ~ zbv * zlog.apen + probeix + block_num + (1|subj/condition)),
  formula(probe.response ~ zbv * zlog.apen + probeix + block_num + condition + (1|subj/condition)),
  formula(probe.response ~ zbv * zlog.apen + probeix + block_num + condition + randomization + (1|subj/condition)),
  formula(probe.response ~ zbv * zlog.apen + probeix + block_num + condition + visit + (1|subj/condition)) + (1|visit/condition),
  formula(probe.response ~ zbv * zlog.apen + probeix + block_num + condition + visit + randomization + (1|subj/condition))
)

descriptions_task=c(
  "BV x AE", 
  "BV x AE + trial", 
  "BV x AE + trial + block", 
  "BV x AE + trial + block + condition",
  "BV x AE + trial + block + condition + randomization",
  "BV x AE + trial + block + condition + visit",
  "BV x AE + trial + block + condition + visit + randomization"
  )

names(models_task) <- sprintf("mod_task%02i", 0:(length(models_task)-1))

models_task.wrap <- map2(names(models_task), models_task, ~ list(mod.name=.x, mod=.y))
models_task.fitted=lapply(models_task.wrap, function(lmod){ fit_and_plot(lmod$mod.name, lmod$mod, load.only=T,plot.only.new=F, dataset = tms_data.nback)})
names(models_task.fitted) <- names(models_task)

loos_task=if.cached.load("loos",
                    invoke(loo_wrapper, .x = models_task.fitted, model_names = names(models_task.fitted)),
                    base=bname)

mod_task.weights = if.cached.load("mod_task.weights",
                             map_df(c("loo", "waic", "stacking"), function(strat) {
                               r = invoke(
                                 model_weights_wrapper,
                                 .x = models_task.fitted,
                                 weights = strat,
                                 model_names = names(models_task.fitted)
                               )
                               bind_cols(strategy = strat, data.frame(t(r)))
                             }), bname)
```

## R-squared

```{r, output = 'asis', results = "hold",comment = "", warning = FALSE}

lapply(models_task.fitted, bayes_R2, cl = 22)

```

## Model Diagnostocs

```{r, output = 'asis', results = "hold",comment = "", warning = FALSE}

loos_task

```

```{r, output = 'asis', results = "hold",comment = "", warning = FALSE}
mod_task.weights

```


```{r, include = F, echo = F,  warning = FALSE}
mod.desc=data.frame(mod=names(models_task.fitted), descriptions_task)
map_df(c("loo","stacking","waic"), ~ cbind(strategy=.x,mod.desc)) %>%
  spread(strategy,descriptions_task) %>%
  #mutate(loo2="",waic="") %>%
  gather(strategy,descriptions,loo,stacking,waic) -> mod.desc
```

## Model selection based on LOO weights. Sum equals to 1. More weight given to model 6.


```{r,echo = F,  warning = FALSE}
mod_task.weights %>%
  gather(mod, prob, starts_with("mod")) %>% 
  full_join(mod.desc) %>%
  mutate(
    strategy=ordered(strategy, c("loo", "waic","stacking")),
    strategy=ordered(case_when(strategy=="loo" ~ "LOO",
                               strategy=="waic" ~ "WAIC"), #strategy=="stacking" ~ "pseudo-BMA"
                     c("LOO","WAIC"))) %>% #"pseudo-BMA"
  filter(strategy!="WAIC") %>% droplevels %>%
  group_by(strategy) %>%
  mutate(win=if_else(prob==max(prob), T,F)) %>%
  ungroup %>%
  ggplot(aes(mod, prob, fill = win)) +
  geom_bar(stat = "identity", position =
             position_dodge()) + coord_flip() +
  scale_fill_manual(values=c("lightblue", "orange"))+
  geom_text(mapping=aes(fill=NULL, label=descriptions), y=0, hjust="left")+
  labs(x="",y="Posterior Probability")+
  facet_wrap(~strategy)+
  theme(axis.ticks.y = element_blank(),
        legend.position = "none",
        axis.text.y=element_blank(),
        panel.grid = element_blank(),
        strip.background = element_blank(),
        strip.text = element_text(size=12),
        strip.placement = "inside") 
```




## Posteior predictive check of the winning model


```{r,  warning = FALSE}
pp_check(models_task.fitted[6]$mod_task05, "ecdf_overlay")
```


## Pairplot for 3 parameters: red dots indicate divergent transitions in the Markov chain

```{r, out.height="100%", out.width= "100%"}
posterior_model_task_5 <- as.array(models_task.fitted[6]$mod_task05)
np_task_model_5 <- nuts_params(models_task.fitted[6]$mod_task05)
mcmc_pairs(posterior_model_task_5, pars = c("b_zbv", "b_zlog.apen", "b_conditionactive_rhTMS") , np = np_task_model_5,
           off_diag_args = list(size = 0.75))

```


## Model Coefficients: lots of uncertainty around stimulation (90%-intervals)

```{r}
mod=models_task.fitted[6]$mod_task05
mcmc_intervals_data(as.matrix(mod), prob_outer = 0.9 ) %>%
  filter(parameter!="lp__", !str_detect(parameter, "subj")) %>%
  filter(!str_detect(parameter, "Intercept")) %>%
  ggplot(aes(y=m, ymin=ll,ymax=hh,x=parameter))+
  geom_pointrange(position=position_dodge(width=0.2))+
  coord_flip()+geom_hline(yintercept = 0, color="red")+
  labs(y="Coefficient")
```



